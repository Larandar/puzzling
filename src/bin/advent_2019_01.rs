use puzzling::advent_of_code::{daily_challenge, AdventOfCode};
use puzzling::prelude::*;

type Input = usize;
type Answer = usize;

#[derive(Debug, Clone)]
struct Puzzle {
    modules: Vec<Input>,
}

// TODO(macro): Add derive macro for standard implementation of FromStr
impl FromStr for Puzzle {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self> {
        unindent::unindent(s)
            .split_terminator("\n")
            .map(|x| -> Result<Input, _> { x.parse() })
            .map(|v| v.map_err(|e| anyhow!(e)))
            .collect::<Result<_>>()
            .map(|lines: Vec<Input>| -> Self { lines.into() })
    }
}

impl From<Vec<Input>> for Puzzle {
    fn from(input: Vec<Input>) -> Self {
        Self { modules: input }
    }
}

impl AdventOfCode for Puzzle {
    type Input = Input;
    type Answer = Answer;
    type Puzzle = Puzzle;

    fn part_one(&self) -> Self::Answer {
        self.modules
            .iter()
            .map(|m| -> Answer { ((*m as f64) / 3.).floor() as Input - 2 })
            .sum()
    }

    fn part_two(&self) -> Self::Answer {
        fn fuel_needed(module: Input) -> Answer {
            let fuel = ((module as f64) / 3.).floor() as isize - 2;
            match fuel {
                1.. => fuel as Input + fuel_needed(fuel as Input),
                _ => 0,
            }
        }
        self.modules.iter().map(|m| fuel_needed(*m)).sum()
    }
}

// TODO(macro): make reusable code be generated by macro
// TODO(bootstrap): initialize and use log crate
fn main() -> Result<()> {
    // SECTION: BOOTSTRAP
    puzzling::logging::initialize_logging();
    // !SECTION

    let puzzle = daily_challenge(2019, 01)?.parse::<Puzzle>()?;

    println!("Part 1: {}", puzzle.part_one());
    println!("Part 2: {}", puzzle.part_two());

    Ok(())
}

#[cfg(test)]
#[cfg(feature = "advent_2019")]
#[cfg(feature = "completed")]
mod tests {

    #[allow(unused_imports)]
    mod advent_2019_01 {
        use crate::Puzzle;
        use puzzling::{advent_of_code::AdventOfCode, prelude::*};

        // SECTION: PART ONE

        /// Solver: Puzzle::part_one
        /// Test Case: sample_1
        #[test]
        fn part_one_sample_1() {
            let puzzle: Puzzle = r#"12"#.parse().expect("failed to parse input string");

            assert_eq!(puzzle.part_one(), 2);
        }

        /// Solver: Puzzle::part_one
        /// Test Case: sample_2
        #[test]
        fn part_one_sample_2() {
            let puzzle: Puzzle = r#"14"#.parse().expect("failed to parse input string");

            assert_eq!(puzzle.part_one(), 2);
        }

        /// Solver: Puzzle::part_one
        /// Test Case: sample_3
        #[test]
        fn part_one_sample_3() {
            let puzzle: Puzzle = r#"1969"#.parse().expect("failed to parse input string");

            assert_eq!(puzzle.part_one(), 654);
        }

        /// Solver: Puzzle::part_one
        /// Test Case: sample_4
        #[test]
        fn part_one_sample_4() {
            let puzzle: Puzzle = r#"100756"#.parse().expect("failed to parse input string");

            assert_eq!(puzzle.part_one(), 33583);
        }

        // !SECTION

        // SECTION: PART TWO

        // !SECTION
    }
}
